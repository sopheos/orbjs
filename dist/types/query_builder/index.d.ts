/**
 * Query Builder
 */
export declare class QB {
    private data_save;
    private query_str;
    private query_data;
    private data_keys;
    private data_values;
    private data_raw_keys;
    private data_raw_values;
    private from_stmt;
    private group_stmt;
    private group_count;
    private group_level;
    private having_data;
    private having_stmt;
    private is_distinct;
    private join_stmt;
    private limit_nb;
    private offset_nb;
    private order_by;
    private select_stmt;
    private where_data;
    private where_stmt;
    constructor();
    reset(): QB;
    save(name?: string): QB;
    load(name?: string): QB;
    export(): {
        data_keys: any[];
        data_values: any[];
        data_raw_keys: string[];
        data_raw_values: string[];
        from_stmt: string;
        group_stmt: string;
        group_count: number;
        group_level: number;
        having_data: any[];
        having_stmt: string;
        is_distinct: boolean;
        join_stmt: string;
        limit_nb: number;
        offset_nb: number;
        order_by: string;
        select_stmt: string;
        where_data: any[];
        where_stmt: string;
    };
    select(...cols: string[]): QB;
    distinct(is_distinct?: boolean): QB;
    from(table: string): QB;
    join(table: string, cond: string): QB;
    left(table: string, cond: string): QB;
    right(table: string, cond: string): QB;
    private _join;
    where(statement: string, ...values: any[]): QB;
    orWhere(statement: string, ...values: any[]): QB;
    whereIn(col: string, values: any[]): QB;
    orWhereIn(col: string, values: any[]): QB;
    whereNotIn(col: string, values: any[]): QB;
    orWhereNotIn(col: string, values: any[]): QB;
    like(col: string, value: any): QB;
    orLike(col: string, value: any): QB;
    notLike(col: string, value: any): QB;
    orNotLike(col: string, value: any): QB;
    search(cols: string[], values: string[]): QB;
    groupStart(): QB;
    orGroupStart(): QB;
    groupEnd(): QB;
    private _where;
    private _in;
    private _group;
    groupBy(...cols: string[]): QB;
    having(statement: string, ...values: any[]): QB;
    orHaving(statement: string, ...values: any[]): QB;
    private _having;
    orderBy(...cols: string[]): QB;
    orderAsc(...cols: string[]): QB;
    orderDesc(...cols: string[]): QB;
    private _order;
    limit(limit: number, offset?: number): QB;
    add(col: string, value: any): QB;
    addRaw(col: string, value: any): QB;
    addList(data: any): QB;
    addListRaw(data: any): QB;
    read(): QB;
    count(): QB;
    insert(): QB;
    replace(): QB;
    update(): QB;
    delete(): QB;
    batch(table: string, data: any[], replace?: boolean): this;
    private _buildSelect;
    private _buildFrom;
    private _buildJoin;
    private _buildWhere;
    private _buildGroupBy;
    private _buildHaving;
    private _buildOrderBy;
    private _buildLimit;
    private _buildInsert;
    private _buildUpdate;
    private _buildDelete;
    query(): string;
    data(): any[];
    toString: () => string;
}
