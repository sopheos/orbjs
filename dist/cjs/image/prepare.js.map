{"version":3,"sources":["../../../src/image/prepare.ts"],"names":["isFileTypeValid","file","allowedTypes","some","allowedType","type","isFileSizeValid","maxSize","size","isImageMinSizeValid","image","options","minWidth","minHeight","width","height","isImageMaxSizeValid","maxWidth","maxHeight","handleOrientationAllowed","orientationAllowed","resizeAndConvert","Promise","resolve","reject","exif","document","createElement","onload","canvas","context","getContext","autoCrop","lessCrop","maxWRatio","maxHRatio","ratios","filter","ratio","length","Math","min","max","newWidth","newHeight","minWRatio","minHRatio","sourceWidth","sourceHeight","x","y","drawImage","metadata","name","value","String","quality","lat","lon","push","toBlob","blob","nameSplit","split","pop","nameParts","replace","newFile","File","join","outputType","reader","FileReader","event","result","target","urlCreator","window","URL","webkitURL","Data","ExifParserFactory","create","parse","tags","GPSLatitude","GPSLongitude","src","createObjectURL","readAsArrayBuffer","imagePrepare","imageOptions","then","res","catch","e"],"mappings":"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","sourcesContent":["import { ExifParserFactory } from \"ts-exif-parser\";\n\ninterface metadata {\n  name: string;\n  value: string | Blob;\n  fileName?: string;\n}\n\nexport interface ImagePrepareOptions {\n  /**\n   * File name\n   * @default 'file'\n   */\n  name?: string;\n\n  /**\n   * Max File Size\n   * @default 20971520\n   */\n  maxSize?: number;\n\n  /**\n   * Image AllowedTypes Format types MIME\n   * @default ['image/jpeg', 'image/png']\n   */\n  allowedTypes?: Array<string>;\n\n  /**\n   * Image AllowedTypes Format types MIME\n   * @default 'image/jpeg'\n   */\n  outputType?: string;\n\n  /**\n   * Compression quality of the jpeg conversion\n   * @default 0.75\n   */\n  quality?: number;\n\n  /** Max width of the image. If to big, image is resized */\n  maxWidth?: number;\n\n  /** Max height of the image. If to big, image is resized */\n  maxHeight?: number;\n\n  /** Min width of the image. If to small, throw an error */\n  minWidth?: number;\n\n  /** Min height of the image. If to small, throw an error */\n  minHeight?: number;\n\n  /**\n   * If true, the max/min Width & Height are interchangeables for validation & resize.\n   * @default true\n   */\n  orientationAllowed?: boolean;\n\n  /**\n   * If true, the exceeding part will be crop.\n   * @default false\n   */\n  autoCrop?: boolean;\n\n  /**\n   * Resize strategy when the picture is too big (keep the ratio)\n   * False => Biggest pictures possible, max resolution but can crop a huge part of the picture\n   * True => Keep the most of the picture, min crop but can drop the quality of the picture\n   * @default true\n   */\n  lessCrop?: boolean;\n}\n\n/**\n * Check if allowed type\n * @param image\n * @param options\n * @returns boolean\n */\nconst isFileTypeValid = (file: File, allowedTypes: Array<string>) => {\n  return (\n    !allowedTypes ||\n    allowedTypes.some((allowedType) => allowedType === file.type)\n  );\n};\n\n/**\n * Check if file is too heavy\n * @param image\n * @param options\n * @returns boolean\n */\nconst isFileSizeValid = (file: File, maxSize: number) => {\n  return !maxSize || file.size < maxSize;\n};\n\n/**\n * Check if image is big enough\n * @param image\n * @param options\n * @returns boolean\n */\nconst isImageMinSizeValid = (\n  image: HTMLImageElement,\n  options: ImagePrepareOptions\n) => {\n  return (\n    !(options.minWidth && options.minHeight) ||\n    (image.width >= options.minWidth && image.height >= options.minHeight)\n  );\n};\n\n/**\n * Check if image is small enough\n * @param image\n * @param options\n * @returns boolean\n */\nconst isImageMaxSizeValid = (\n  image: HTMLImageElement,\n  options: ImagePrepareOptions\n) => {\n  return (\n    !(options.maxWidth && options.maxHeight) ||\n    (image.width <= options.maxWidth && image.height <= options.maxHeight)\n  );\n};\n\n/**\n * If orientationAllowed, handle big side/small side instead of width/height\n * @param image\n * @param options\n */\nconst handleOrientationAllowed = (\n  image: HTMLImageElement,\n  options: ImagePrepareOptions\n) => {\n  if (!options.orientationAllowed) return;\n\n  // handle max size. If image is wider than higher we make sur that maxWidth is bigger than maxHeight\n  // if not we swap max size\n  if (options.maxHeight && options.maxWidth) {\n    if (image.width > image.height) {\n      if (options.maxHeight > options.maxWidth) {\n        [options.maxHeight, options.maxWidth] = [\n          options.maxWidth,\n          options.maxHeight,\n        ];\n      }\n    } else if (options.maxHeight < options.maxWidth) {\n      [options.maxHeight, options.maxWidth] = [\n        options.maxWidth,\n        options.maxHeight,\n      ];\n    }\n  }\n\n  // handle min size. If image is wider than higher we make sur that minWidth is bigger than minHeight\n  // if not we swap min size\n  if (options.minHeight && options.minWidth) {\n    if (image.width > image.height) {\n      if (options.minHeight > options.minWidth) {\n        [options.minHeight, options.minWidth] = [\n          options.minWidth,\n          options.minHeight,\n        ];\n      }\n    } else if (options.minHeight < options.minWidth) {\n      [options.minHeight, options.minWidth] = [\n        options.minWidth,\n        options.minHeight,\n      ];\n    }\n  }\n};\n\n/**\n * Optimize a file\n * Handle validation error\n * @param file\n * @param options\n * @returns a promise resolving to a new file and is metadata (otherwise a validation error)\n */\nconst resizeAndConvert = (\n  file: File,\n  options: ImagePrepareOptions\n): Promise<any> => {\n  return new Promise((resolve, reject) => {\n    let exif: any;\n\n    const image = document.createElement(\"img\");\n    image.onload = () => {\n      const canvas = document.createElement(\"canvas\");\n      const context = canvas.getContext(\"2d\")!;\n      let { width, height } = image;\n\n      handleOrientationAllowed(image, options);\n\n      if (!isImageMinSizeValid(image, options)) {\n        reject(\"minsize\");\n      }\n\n      if (!options.autoCrop && !isImageMaxSizeValid(image, options)) {\n        reject(\"maxsize\");\n      }\n\n      // if no max/min size, set max/min size to width/height\n      const {\n        maxWidth = width,\n        maxHeight = height,\n        minWidth = width,\n        minHeight = height,\n        lessCrop,\n      } = options;\n\n      // Define ratio to have the biggest image allowed\n      const maxWRatio = maxWidth / width;\n      const maxHRatio = maxHeight / height;\n      const ratios = [maxWRatio, maxHRatio].filter((ratio) => ratio < 1);\n      let ratio = 1;\n      if (ratios.length > 0) {\n        ratio = lessCrop ? Math.min(...ratios) : Math.max(...ratios);\n      }\n      let newWidth = width * ratio;\n      let newHeight = height * ratio;\n\n      // Make sure the ratio respect min size if we need to resize down the image\n      if (newWidth < minWidth || newHeight < minHeight) {\n        const minWRatio = minWidth / width;\n        const minHRatio = minHeight / height;\n        const ratios = [minWRatio, minHRatio].filter((ratio) => ratio < 1);\n        ratio = ratios.length > 0 ? Math.max(...ratios) : 1;\n        newWidth = width * ratio;\n        newHeight = height * ratio;\n      }\n\n      let sourceWidth = newWidth > maxWidth ? maxWidth / ratio : width;\n      let sourceHeight = newHeight > maxHeight ? maxHeight / ratio : height;\n      let x = 0;\n      let y = 0;\n\n      // if needed, offset the exceeding part on the x axis\n      if (newWidth > maxWidth) {\n        x = (width - sourceWidth) / 2;\n        newWidth = maxWidth;\n      }\n\n      // if needed, offset the exceeding part on the y axis\n      if (newHeight > maxHeight) {\n        y = (height - sourceHeight) / 2;\n        newHeight = maxHeight;\n      }\n\n      canvas.width = newWidth;\n      canvas.height = newHeight;\n      context.drawImage(\n        image,\n        x,\n        y,\n        sourceWidth,\n        sourceHeight,\n        0,\n        0,\n        canvas.width,\n        canvas.height\n      );\n\n      const metadata: Array<metadata> = [\n        {\n          name: \"metadata[quality]\",\n          value: String(options.quality),\n        },\n      ];\n\n      if (exif && exif.lat && exif.lon) {\n        metadata.push(\n          {\n            name: \"metadata[lat]\",\n            value: exif.lat,\n          },\n          {\n            name: \"metadata[lon]\",\n            value: exif.lon,\n          }\n        );\n      }\n\n      canvas.toBlob(\n        (blob: Blob | null): void => {\n          if (!blob) {\n            reject(\"default\");\n          } else {\n            // Rename file with correct extension\n            const nameSplit = file.name.split(\".\");\n            nameSplit.pop();\n\n            const nameParts = [...nameSplit, blob.type.replace(\"image/\", \"\")];\n            const newFile = new File([blob], nameParts.join(\".\"), {\n              type: blob.type,\n            });\n\n            resolve({\n              file: newFile,\n              metadata,\n            });\n          }\n        },\n        options.outputType,\n        options.quality\n      );\n    };\n\n    const reader = new FileReader();\n    reader.onload = (event) => {\n      const result = event.target!.result;\n\n      const urlCreator = window.URL || window.webkitURL;\n\n      if (result && typeof result !== \"string\") {\n        const Data = ExifParserFactory.create(result).parse();\n        if (Data && Data.tags!.GPSLatitude && Data.tags!.GPSLongitude) {\n          const lat = String(Data.tags!.GPSLatitude);\n          const lon = String(Data.tags!.GPSLongitude);\n          exif = { lat, lon };\n        }\n      }\n      image.src = urlCreator.createObjectURL(file);\n    };\n    reader.readAsArrayBuffer(file);\n  });\n};\n\n/**\n * Optimize a file\n * Handle validation error\n * @param blob\n * @param options\n * @returns a promise resolving to a new file and is metadata (otherwise a validation error)\n */\nexport const imagePrepare = (\n  blob: Blob,\n  options: ImagePrepareOptions\n): Promise<any> => {\n  return new Promise(async (resolve, reject) => {\n    const imageOptions = {\n      name: \"file\",\n      maxSize: 20971520,\n      allowedTypes: [\"image/jpeg\", \"image/png\"],\n      outputType: \"image/jpeg\",\n      quality: 0.75,\n      orientationAllowed: true,\n      autoCrop: false,\n      lessCrop: true,\n      ...options,\n    };\n\n    const file = new File([blob], imageOptions.name, { type: blob.type });\n\n    if (!isFileTypeValid(file, imageOptions.allowedTypes)) {\n      reject(\"invalid_filetype\");\n    }\n\n    if (!isFileSizeValid(file, imageOptions.maxSize)) {\n      reject(\"invalid_filesize\");\n    }\n\n    resizeAndConvert(file, imageOptions)\n      .then((res) => {\n        resolve(res);\n      })\n      .catch((e) => {\n        reject(e);\n      });\n  });\n};\n"],"file":"prepare.js"}